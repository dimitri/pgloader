<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="../../docs-assets/ico/favicon.png">

    <title>pgloader</title>

    <!-- Bootstrap core CSS -->
    <link href="../dist/css/bootstrap.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../dist/carousel.css" rel="stylesheet">
  </head>
<!-- NAVBAR
================================================== -->
  <body>
    <div class="navbar-wrapper">
      <div class="container">

        <div class="navbar navbar-inverse navbar-static-top" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../index.html">pgloader</a>
            </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">
                <li><a href="../index.html">Home</a></li>
                <li><a href="quickstart.html">Quick Start</a></li>
                <li><a href="pgloader.1.html">Reference documentation</a></li>
                <li class="dropdown active">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Advanced HowTos <b class="caret"></b></a>
                  <ul class="dropdown-menu">
                    <li class="dropdown-header">Plain Files</li>
                    <li><a href="csv.html">CSV</a></li>
                    <li><a href="fixed.html">Fixed format</a></li>
                    <li><a href="geolite.html">Geolite</a></li>
                    <li class="divider"></li>
                    <li class="dropdown-header">Databases</li>
                    <li><a href="dBase.html">dBase</a></li>
                    <li><a href="sqlite.html">SQLite</a></li>
                    <li><a href="mysql.html">MySQL</a></li>
                  </ul>
                </li>
                <li><a href="../download.html">Download</a></li>
                <li><a href="../sponsors.html">Sponsors</a></li>
                <li><a href="../pgloader-moral-license.html">License</a></li>
              </ul>
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- an empty carousel -->
    <div id="myCarousel" class="carousel slide" data-ride="carousel" style="height: 100px">
      <div class="carousel-inner" style="height: 100px">
        <div class="item active" style="height: 100px">
          <img data-src="holder.js/900x100/auto/#777:#7a7a7a" style="height: 100px">
          <!-- <div class="container"> -->
          <!--   <div class="carousel-caption"> -->
          <!--     <h1>Load data into PostgreSQL. Fast.</h1> -->
          <!--     <p></p> -->
          <!--   </div> -->
          <!-- </div> -->
        </div>
      </div>
    </div><!-- /.carousel -->

    <div class="container">
      <div class="row">
        <div class="col-md-2"> </div>
        <div class="col-md-8">
<h1>pgloader(1) -- PostgreSQL data loader</h1><h2>SYNOPSIS</h2><pre><code>pgloader [&lt;options&gt;] [&lt;command-file&gt;]...  
pgloader [&lt;options&gt;] SOURCE TARGET </code></pre><h2>DESCRIPTION</h2><p>pgloader loads data from various sources into PostgreSQL. It can transform the data it reads on the fly and submit raw SQL before and after the loading.  It uses the <code>COPY</code> PostgreSQL protocol to stream the data into the server, and manages errors by filling a pair of <em>reject.dat</em> and <em>reject.log</em> files. </p><p>pgloader operates either using commands which are read from files: </p><pre><code>pgloader commands.load </code></pre><p>or by using arguments and options all provided on the command line: </p><pre><code>pgloader SOURCE TARGET </code></pre><h2>ARGUMENTS</h2><p>The pgloader arguments can be as many load files as needed, or a couple of connection strings to a specific input file. </p><h3>SOURCE CONNECTION STRING</h3><p>The source connection string format is as follows: </p><pre><code>format:///absolute/path/to/file.ext  
format://./relative/path/to/file.ext </code></pre><p>Where format might be one of <code>csv</code>, <code>fixed</code>, <code>copy</code>, <code>dbf</code>, <code>db3</code> or <code>ixf</code>. </p><pre><code>db://user:pass@host:port/dbname </code></pre><p>Where db might be of <code>sqlite</code>, <code>mysql</code> or <code>mssql</code>. </p><p>When using a file based source format, pgloader also support natively fetching the file from an http location and decompressing an archive if needed. In that case it's necessary to use the <code>--type</code> option to specify the expected format of the file. See the examples below. </p><p>Also note that some file formats require describing some implementation details such as columns to be read and delimiters and quoting when loading from csv. </p><p>For more complex loading scenarios, you will need to write a full fledge load command in the syntax described later in this document. </p><h3>TARGET CONNECTION STRING</h3><p>The target connection string format is described in details later in this document, see Section Connection String. </p><h2>OPTIONS</h2><h3>INQUIRY OPTIONS</h3><p>Use these options when you want to know more about how to use <code>pgloader</code>, as those options will cause <code>pgloader</code> not to load any data. </p><ul><li><p><code>-h</code>, <code>--help</code>: Show command usage summary and exit. </p></li><li><p><code>-V</code>, <code>--version</code>: Show pgloader version string and exit. </p></li><li><p><code>-E</code>, <code>--list-encodings</code>: List known encodings in this version of pgloader. </p></li><li><p><code>-U</code>, <code>--upgrade-config</code>: Parse given files in the command line as <code>pgloader.conf</code> files with the    <code>INI</code> syntax that was in use in pgloader versions 2.x, and output the    new command syntax for pgloader on standard output. </p></li></ul><h3>GENERAL OPTIONS</h3><p>Those options are meant to tweak <code>pgloader</code> behavior when loading data. </p><ul><li><p><code>-v</code>, <code>--verbose</code>: Be verbose. </p><li><p><code>-q</code>, <code>--quiet</code>: Be quiet. </p></li><li><p><code>-d</code>, <code>--debug</code>: Show debug level information messages. </p></li><li><p><code>-D</code>, <code>--root-dir</code>: Set the root working directory (default to "/tmp/pgloader"). </p></li><li><p><code>-L</code>, <code>--logfile</code>: Set the pgloader log file (default to "/tmp/pgloader.log"). </p></li><li><p><code>--log-min-messages</code>: Minimum level of verbosity needed for log message to make it to the logfile. One of critical, log, error, warning, notice, info or debug. </p></li><li><p><code>--client-min-messages</code>: Minimum level of verbosity needed for log message to make it to the console. One of critical, log, error, warning, notice, info or debug. </p></li><li><p><code>-S</code>, <code>--summary</code>: A filename where to copy the summary output. When relative, the filename is expanded into <code>*root-dir*</code>. </p></li></li><p>The format of the filename defaults to being <em>human readable</em>. It is possible to have the output in machine friendly formats such as <em>CSV</em>, <em>COPY</em> (PostgreSQL's own COPY format) or <em>JSON</em> by specifying a filename with the extension resp. <code>.csv</code>, <code>.copy</code> or <code>.json</code>. </p><li><p><code>-l &lt;file&gt;</code>, <code>--load-lisp-file &lt;file&gt;</code>: Specify a lisp <file>  to compile and load into the pgloader image before reading the commands, allowing to define extra transformation function. Those functions should be defined in the <code>pgloader.transforms</code> package. This option can appear more than once in the command line. </p></li><li><p><code>--dry-run</code>:</p><p>Allow testing a <code>.load</code> file without actually trying to load any data. It's useful to debug it until it's ok, in particular to fix connection strings. </p></li><li><code>--on-error-stop</code><p>Alter pgloader behavior: rather than trying to be smart about error handling and continue loading good data, separating away the bad one, just stop as soon as PostgreSQL refuses anything sent to it. Useful to debug data processing, transformation function and specific type casting. </p></li><li><code>--self-upgrade &lt;directory&gt;</code>:<p>Specify a <directory>  where to find pgloader sources so that one of the very first things it does is dynamically loading-in (and compiling to machine code) another version of itself, usually a newer one like a very recent git checkout. </p></li></ul><h3>COMMAND LINE ONLY OPERATIONS</h3><p>Those options are meant to be used when using <code>pgloader</code> from the command line only, rather than using a command file and the rich command clauses and parser. In simple cases, it can be much easier to use the <em>SOURCE</em> and <em>TARGET</em> directly on the command line, then tweak the loading with those options: </p><ul><li><code>--with "option"</code>:<p>Allows setting options from the command line. You can use that option as many times as you want. The option arguments must follow the <em>WITH</em> clause for the source type of the <code>SOURCE</code> specification, as described later in this document. </p></li><li><code>--set "guc_name='value'"</code><p>Allows setting PostgreSQL configuration from the command line. Note that the option parsing is the same as when used from the <em>SET</em> command clause, in particular you must enclose the guc value with single-quotes. </p></li><li><code>--field "..."</code><p>Allows setting a source field definition. Fields are accumulated in the order given on the command line. It's possible to either use a <code>--field</code> option per field in the source file, or to separate field definitions by a comma, as you would do in the <em>HAVING FIELDS</em> clause. </p></li><li><code>--cast "..."</code><p>Allows setting a specific casting rule for loading the data. </p></li><li><code>--type csv|fixed|db3|ixf|sqlite|mysql|mssql</code><p>Allows forcing the source type, in case when the <em>SOURCE</em> parsing isn't satisfying. </p></li><li><code>--encoding &lt;encoding&gt;</code><p>Set the encoding of the source file to load data from. </p></li><li><code>--before &lt;filename&gt;</code><p>Parse given filename for SQL queries and run them against the target database before loading the data from the source. The queries are parsed by pgloader itself: they need to be terminated by a semi-colon (;) and the file may include <code>\i</code> or <code>\ir</code> commands to <em>include</em> another file. </p></li><li><code>--after &lt;filename&gt;</code><p>Parse given filename for SQL queries and run them against the target database after having loaded the data from the source. The queries are parsed in the same way as with the <code>--before</code> option, see above. </p></li></ul><h3>MORE DEBUG INFORMATION</h3><p>To get the maximum amount of debug information, you can use both the <code>--verbose</code> and the <code>--debug</code> switches at the same time, which is equivalent to saying <code>--client-min-messages data</code>. Then the log messages will show the data being processed, in the cases where the code has explicit support for it. </p><h2>USAGE EXAMPLES</h2><p>Review the command line options and pgloader's version: </p><pre><code>pgloader --help  
pgloader --version </code></pre><h3>Loading from a complex command</h3><p>Use the command file as the pgloader command argument, pgloader will parse that file and execute the commands found in it: </p><pre><code>pgloader --verbose ./test/csv-districts.load </code></pre><h3>CSV</h3><p>Load data from a CSV file into a pre-existing table in your database: </p><pre><code>pgloader --type csv                                   \  
         --field id --field field                     \  
         --with truncate                              \  
         --with "fields terminated by ','"            \  
         ./test/data/matching-1.csv                   \  
         postgres:///pgloader?tablename=matching </code></pre><p>In that example the whole loading is driven from the command line, bypassing the need for writing a command in the pgloader command syntax entirely. As there's no command though, the extra inforamtion needed must be provided on the command line using the <code>--type</code> and <code>--field</code> and <code>--with</code> switches. </p><p>For documentation about the available syntaxes for the <code>--field</code> and <code>--with</code> switches, please refer to the CSV section later in the man page. </p><p>Note also that the PostgreSQL URI includes the target <em>tablename</em>. </p><h3>Reading from STDIN</h3><p>File based pgloader sources can be loaded from the standard input, as in the following example: </p><pre><code>pgloader --type csv                                         \  
         --field "usps,geoid,aland,awater,aland_sqmi,awater_sqmi,intptlat,intptlong" \  
         --with "skip header = 1"                          \  
         --with "fields terminated by '\t'"                \  
         -                                                 \  
         postgresql:///pgloader?districts_longlat          \  
         &lt; test/data/2013_Gaz_113CDs_national.txt </code></pre><p>The dash (<code>-</code>) character as a source is used to mean <em>standard input</em>, as usual in Unix command lines. It's possible to stream compressed content to pgloader with this technique, using the Unix pipe: </p><pre><code>gunzip -c source.gz | pgloader --type csv ... - pgsql:///target?foo </code></pre><h3>Loading from CSV available through HTTP</h3><p>The same command as just above can also be run if the CSV file happens to be found on a remote HTTP location: </p><pre><code>pgloader --type csv                                                     \  
         --field "usps,geoid,aland,awater,aland_sqmi,awater_sqmi,intptlat,intptlong" \  
         --with "skip header = 1"                                       \  
         --with "fields terminated by '\t'"                             \  
         http://pgsql.tapoueh.org/temp/2013_Gaz_113CDs_national.txt     \  
         postgresql:///pgloader?districts_longlat </code></pre><p>Some more options have to be used in that case, as the file contains a one-line header (most commonly that's column names, could be a copyright notice). Also, in that case, we specify all the fields right into a single <code>--field</code> option argument. </p><p>Again, the PostgreSQL target connection string must contain the <em>tablename</em> option and you have to ensure that the target table exists and may fit the data. Here's the SQL command used in that example in case you want to try it yourself: </p><pre><code>create table districts_longlat  
(  
         usps        text,  
         geoid       text,  
         aland       bigint,  
         awater      bigint,  
         aland_sqmi  double precision,  
         awater_sqmi double precision,  
         intptlat    double precision,  
         intptlong   double precision  
); </code></pre><p>Also notice that the same command will work against an archived version of the same data, e.g. http://pgsql.tapoueh.org/temp/2013<em>Gaz</em>113CDs_national.txt.gz. </p><p>Finally, it's important to note that pgloader first fetches the content from the HTTP URL it to a local file, then expand the archive when it's recognized to be one, and only then processes the locally expanded file. </p><p>In some cases, either because pgloader has no direct support for your archive format or maybe because expanding the archive is not feasible in your environment, you might want to <em>stream</em> the content straight from its remote location into PostgreSQL. Here's how to do that, using the old battle tested Unix Pipes trick: </p><pre><code>curl http://pgsql.tapoueh.org/temp/2013_Gaz_113CDs_national.txt.gz \  
| gunzip -c                                                        \  
| pgloader --type csv                                              \  
           --field "usps,geoid,aland,awater,aland_sqmi,awater_sqmi,intptlat,intptlong"  
           --with "skip header = 1"                                \  
           --with "fields terminated by '\t'"                      \  
           -                                                       \  
           postgresql:///pgloader?districts_longlat </code></pre><p>Now the OS will take care of the streaming and buffering between the network and the commands and pgloader will take care of streaming the data down to PostgreSQL. </p><h3>Migrating from SQLite</h3><p>The following command will open the SQLite database, discover its tables definitions including indexes and foreign keys, migrate those definitions while <em>casting</em> the data type specifications to their PostgreSQL equivalent and then migrate the data over: </p><pre><code>createdb newdb  
pgloader ./test/sqlite/sqlite.db postgresql:///newdb </code></pre><h3>Migrating from MySQL</h3><p>Just create a database where to host the MySQL data and definitions and have pgloader do the migration for you in a single command line: </p><pre><code>createdb pagila  
pgloader mysql://user@localhost/sakila postgresql:///pagila </code></pre><h3>Fetching an archived DBF file from a HTTP remote location</h3><p>It's possible for pgloader to download a file from HTTP, unarchive it, and only then open it to discover the schema then load the data: </p><pre><code>createdb foo  
pgloader --type dbf http://www.insee.fr/fr/methodes/nomenclatures/cog/telechargement/2013/dbf/historiq2013.zip postgresql:///foo </code></pre><p>Here it's not possible for pgloader to guess the kind of data source it's being given, so it's necessary to use the <code>--type</code> command line switch. </p><h2>BATCHES AND RETRY BEHAVIOUR</h2><p>To load data to PostgreSQL, pgloader uses the <code>COPY</code> streaming protocol. While this is the faster way to load data, <code>COPY</code> has an important drawback: as soon as PostgreSQL emits an error with any bit of data sent to it, whatever the problem is, the whole data set is rejected by PostgreSQL. </p><p>To work around that, pgloader cuts the data into <em>batches</em> of 25000 rows each, so that when a problem occurs it's only impacting that many rows of data. Each batch is kept in memory while the <code>COPY</code> streaming happens, in order to be able to handle errors should some happen. </p><p>When PostgreSQL rejects the whole batch, pgloader logs the error message then isolates the bad row(s) from the accepted ones by retrying the batched rows in smaller batches. To do that, pgloader parses the <em>CONTEXT</em> error message from the failed COPY, as the message contains the line number where the error was found in the batch, as in the following example: </p><pre><code>CONTEXT: COPY errors, line 3, column b: "2006-13-11" </code></pre><p>Using that information, pgloader will reload all rows in the batch before the erroneous one, log the erroneous one as rejected, then try loading the remaining of the batch in a single attempt, which may or may not contain other erroneous data. </p><p>At the end of a load containing rejected rows, you will find two files in the <em>root-dir</em> location, under a directory named the same as the target database of your setup. The filenames are the target table, and their extensions are <code>.dat</code> for the rejected data and <code>.log</code> for the file containing the full PostgreSQL client side logs about the rejected data. </p><p>The <code>.dat</code> file is formatted in PostgreSQL the text COPY format as documented in <a href="">http://www.postgresql.org/docs/9.2/static/sql-copy.html#AEN66609</a>. </p><h2>A NOTE ABOUT PERFORMANCE</h2><p>pgloader has been developed with performance in mind, to be able to cope with ever growing needs in loading large amounts of data into PostgreSQL. </p><p>The basic architecture it uses is the old Unix pipe model, where a thread is responsible for loading the data (reading a CSV file, querying MySQL, etc) and fills pre-processed data into a queue. Another threads feeds from the queue, apply some more <em>transformations</em> to the input data and stream the end result to PostgreSQL using the COPY protocol. </p><p>When given a file that the PostgreSQL <code>COPY</code> command knows how to parse, and if the file contains no erroneous data, then pgloader will never be as fast as just using the PostgreSQL <code>COPY</code> command. </p><p>Note that while the <code>COPY</code> command is restricted to read either from its standard input or from a local file on the server's file system, the command line tool <code>psql</code> implements a <code>\copy</code> command that knows how to stream a file local to the client over the network and into the PostgreSQL server, using the same protocol as pgloader uses. </p><h2>A NOTE ABOUT PARALLELISM</h2><p>pgloader uses several concurrent tasks to process the data being loaded: </p><ul><li><p>a reader task reads the data in and pushes it to a queue,</p></li><li><p>at last one write task feeds from the queue and formats the raw into the PostgreSQL COPY format in batches (so that it's possible to then retry a failed batch without reading the data from source again), and then sends the data to PostgreSQL using the COPY protocol. </p></li></ul><p>The parameter <em>workers</em> allows to control how many worker threads are allowed to be active at any time (that's the parallelism level); and the parameter <em>concurrency</em> allows to control how many tasks are started to handle the data (they may not all run at the same time, depending on the <em>workers</em> setting). </p><p>We allow <em>workers</em> simultaneous workers to be active at the same time in the context of a single table. A single unit of work consist of several kinds of workers: </p><ul><li>a reader getting raw data from the source,</li><li>N writers preparing and sending the data down to PostgreSQL.</li></ul><p>The N here is setup to the <em>concurrency</em> parameter: with a <em>CONCURRENCY</em> of 2, we start (+ 1 2) = 3 concurrent tasks, with a <em>concurrency</em> of 4 we start (+ 1 4) = 9 concurrent tasks, of which only <em>workers</em> may be active simultaneously. </p><p>The defaults are <code>workers = 4, concurrency = 1</code> when loading from a database source, and <code>workers = 8, concurrency = 2</code> when loading from something else (currently, a file). Those defaults are arbitrary and waiting for feedback from users, so please consider providing feedback if you play with the settings. </p><p>As the <code>CREATE INDEX</code> threads started by pgloader are only waiting until PostgreSQL is done with the real work, those threads are <em>NOT</em> counted into the concurrency levels as detailed here. </p><p>By default, as many <code>CREATE INDEX</code> threads as the maximum number of indexes per table are found in your source schema. It is possible to set the <code>max parallel create index</code> <em>WITH</em> option to another number in case there's just too many of them to create. </p><h2>SOURCE FORMATS</h2><p>pgloader supports the following input formats: </p><ul><li><p>csv, which includes also tsv and other common variants where you can change the <em>separator</em> and the <em>quoting</em> rules and how to <em>escape</em> the <em>quotes</em> themselves; </p></li><li><p>fixed columns file, where pgloader is flexible enough to accomodate with source files missing columns (<em>ragged fixed length column files</em> do exist); </p></li><li><p>PostgreSLQ COPY formatted files, following the COPY TEXT documentation of PostgreSQL, such as the reject files prepared by pgloader; </p></li><li><p>dbase files known as db3 or dbf file;</p></li><li><p>ixf formated files, ixf being a binary storage format from IBM;</p></li><li><p>sqlite databases with fully automated discovery of the schema and advanced cast rules; </p></li><li><p>mysql databases with fully automated discovery of the schema and advanced cast rules; </p></li><li><p>MS SQL databases with fully automated discovery of the schema and advanced cast rules. </p></li></ul><h2>PGLOADER COMMANDS SYNTAX</h2><p>pgloader implements a Domain Specific Language allowing to setup complex data loading scripts handling computed columns and on-the-fly sanitization of the input data. For more complex data loading scenarios, you will be required to learn that DSL's syntax. It's meant to look familiar to DBA by being inspired by SQL where it makes sense, which is not that much after all. </p><p>The pgloader commands follow the same global grammar rules. Each of them might support only a subset of the general options and provide specific options. </p><pre><code>LOAD &lt;source-type&gt;  
     FROM &lt;source-url&gt;     [ HAVING FIELDS &lt;source-level-options&gt; ]  
	 INTO &lt;postgresql-url&gt; [ TARGET COLUMNS &lt;columns-and-options&gt; ]  
 
[ WITH &lt;load-options&gt; ]  
 
[ SET &lt;postgresql-settings&gt; ]  
 
[ BEFORE LOAD [ DO &lt;sql statements&gt; | EXECUTE &lt;sql file&gt; ] ... ]  
[  AFTER LOAD [ DO &lt;sql statements&gt; | EXECUTE &lt;sql file&gt; ] ... ]  
; </code></pre><p>The main clauses are the <code>LOAD</code>, <code>FROM</code>, <code>INTO</code> and <code>WITH</code> clauses that each command implements. Some command then implement the <code>SET</code> command, or some specific clauses such as the <code>CAST</code> clause. </p><h2>COMMON CLAUSES</h2><p>Some clauses are common to all commands: </p><ul><li><em>FROM</em><p>The <em>FROM</em> clause specifies where to read the data from, and each command introduces its own variant of sources. For instance, the <em>CSV</em> source supports <code>inline</code>, <code>stdin</code>, a filename, a quoted filename, and a <em>FILENAME MATCHING</em> clause (see above); whereas the <em>MySQL</em> source only supports a MySQL database URI specification. </p></li><p>In all cases, the <em>FROM</em> clause is able to read its value from an environment variable when using the form <code>GETENV 'varname'</code>. </p><li><em>INTO</em></li><p>The PostgreSQL connection URI must contains the name of the target table where to load the data into. That table must have already been created in PostgreSQL, and the name might be schema qualified. </p><p>The <em>INTO</em> target database connection URI can be parsed from the value of an environment variable when using the form <code>GETENV 'varname'</code>. </p><p>Then <em>INTO</em> option also supports an optional comma separated list of target columns, which are either the name of an input <em>field</em> or the white space separated list of the target column name, its PostgreSQL data type and a <em>USING</em> expression. </p><p>The <em>USING</em> expression can be any valid Common Lisp form and will be read with the current package set to <code>pgloader.transforms</code>, so that you can use functions defined in that package, such as functions loaded dynamically with the <code>--load</code> command line parameter. </p><p>Each <em>USING</em> expression is compiled at runtime to native code. </p><p>This feature allows pgloader to load any number of fields in a CSV file into a possibly different number of columns in the database, using custom code for that projection. </p><li><em>WITH</em><p>Set of options to apply to the command, using a global syntax of either: </p><ul><li><em>key = value</em></li><li><em>use option</em></li><li><em>do not use option</em></li></ul></li><p>See each specific command for details. </p><p>All data sources specific commands support the following options: </p><ul><li><em>on error stop</em></li><li><em>batch rows = R</em></li><li><em>batch size = ... MB</em></li><li><em>prefetch rows = ...</em></li></ul><p>See the section BATCH BEHAVIOUR OPTIONS for more details. </p><p>In addition, the following settings are available: </p><ul><li><em>workers = W</em></li><li><em>concurrency = C</em></li><li><em>max parallel create index = I</em></li></ul><p>See section A NOTE ABOUT PARALLELISM for more details. </p><li><em>SET</em><p>This clause allows to specify session parameters to be set for all the sessions opened by pgloader. It expects a list of parameter name, the equal sign, then the single-quoted value as a comma separated list. </p></li><p>The names and values of the parameters are not validated by pgloader, they are given as-is to PostgreSQL. </p><li><em>BEFORE LOAD DO</em></li><p> You can run SQL queries against the database before loading the data  from the <code>CSV</code> file. Most common SQL queries are <code>CREATE TABLE IF NOT  EXISTS</code> so that the data can be loaded. </p><p> Each command must be <em>dollar-quoted</em>: it must begin and end with a  double dollar sign, <code>$$</code>. Dollar-quoted queries are then comma  separated. No extra punctuation is expected after the last SQL query. </p><li><em>BEFORE LOAD EXECUTE</em><p> Same behaviour as in the <em>BEFORE LOAD DO</em> clause. Allows you to read  the SQL queries from a SQL file. Implements support for PostgreSQL  dollar-quoting and the <code>\i</code> and <code>\ir</code> include facilities as in <code>psql</code>  batch mode (where they are the same thing). </p></li><li><em>AFTER LOAD DO</em><p>Same format as <em>BEFORE LOAD DO</em>, the dollar-quoted queries found in that section are executed once the load is done. That's the right time to create indexes and constraints, or re-enable triggers. </p></li><li><em>AFTER LOAD EXECUTE</em><p> Same behaviour as in the <em>AFTER LOAD DO</em> clause. Allows you to read the  SQL queries from a SQL file. Implements support for PostgreSQL  dollar-quoting and the <code>\i</code> and <code>\ir</code> include facilities as in <code>psql</code>  batch mode (where they are the same thing). </p></li></ul><h3>Connection String</h3><p>The <code>&lt;postgresql-url&gt;</code> parameter is expected to be given as a <em>Connection URI</em> as documented in the PostgreSQL documentation at http://www.postgresql.org/docs/9.3/static/libpq-connect.html#LIBPQ-CONNSTRING. </p><pre><code>postgresql://[user[:password]@][netloc][:port][/dbname][?option=value&amp;...] </code></pre><p>Where: </p><ul><li><em>user</em><p>Can contain any character, including colon (<code>:</code>) which must then be doubled (<code>::</code>) and at-sign (<code>@</code>) which must then be doubled (<code>@@</code>). </p></li><p>When omitted, the <em>user</em> name defaults to the value of the <code>PGUSER</code> environment variable, and if it is unset, the value of the <code>USER</code> environment variable. </p><li><em>password</em></li><p>Can contain any character, including the at sign (<code>@</code>) which must then be doubled (<code>@@</code>). To leave the password empty, when the <em>user</em> name ends with at at sign, you then have to use the syntax user:@. </p><p>When omitted, the <em>password</em> defaults to the value of the <code>PGPASSWORD</code> environment variable if it is set, otherwise the password is left unset. </p><li><em>netloc</em><p>Can be either a hostname in dotted notation, or an ipv4, or an Unix domain socket path. Empty is the default network location, under a system providing <em>unix domain socket</em> that method is preferred, otherwise the <em>netloc</em> default to <code>localhost</code>. </p></li><p>It's possible to force the <em>unix domain socket</em> path by using the syntax <code>unix:/path/to/where/the/socket/file/is</code>, so to force a non default socket path and a non default port, you would have: </p><pre><code>postgresql://unix:/tmp:54321/dbname </code></pre><p>The <em>netloc</em> defaults to the value of the <code>PGHOST</code> environment variable, and if it is unset, to either the default <code>unix</code> socket path when running on a Unix system, and <code>localhost</code> otherwise. </p><li><em>dbname</em></li><p>Should be a proper identifier (letter followed by a mix of letters, digits and the punctuation signs comma (<code>,</code>), dash (<code>-</code>) and underscore (<code>_</code>). </p><p>When omitted, the <em>dbname</em> defaults to the value of the environment variable <code>PGDATABASE</code>, and if that is unset, to the <em>user</em> value as determined above. </p><li><em>options</em><p>The optional parameters must be supplied with the form <code>name=value</code>, and you may use several parameters by separating them away using an ampersand (<code>&amp;</code>) character. </p></li><p>Only some options are supported here, <em>tablename</em> (which might be qualified with a schema name) <em>sslmode</em>, <em>host</em>, <em>port</em>, <em>dbname</em>, <em>user</em> and <em>password</em>. </p><p>The <em>sslmode</em> parameter values can be one of <code>disable</code>, <code>allow</code>, <code>prefer</code> or <code>require</code>. </p><p>For backward compatibility reasons, it's possible to specify the <em>tablename</em> option directly, without spelling out the <code>tablename=</code> parts. </p><p>The options override the main URI components when both are given, and using the percent-encoded option parameters allow using passwords starting with a colon and bypassing other URI components parsing limitations. </p></ul><h3>Regular Expressions</h3><p>Several clauses listed in the following accept <em>regular expressions</em> with the following input rules: </p><ul><li><p>A regular expression begins with a tilde sign (<code>~</code>),</p></li><li><p>is then followed with an opening sign,</p></li><li><p>then any character is allowed and considered part of the regular expression, except for the closing sign, </p></li><li><p>then a closing sign is expected.</p></li></ul><p>The opening and closing sign are allowed by pair, here's the complete list of allowed delimiters: </p><pre><code>~//  
~[]  
~{}  
~()  
~&lt;&gt;  
~""  
~''  
~||  
~## </code></pre><p>Pick the set of delimiters that don't collide with the <em>regular expression</em> you're trying to input. If your expression is such that none of the solutions allow you to enter it, the places where such expressions are allowed should allow for a list of expressions. </p><h3>Comments</h3><p>Any command may contain comments, following those input rules: </p><ul><li><p>the <code>--</code> delimiter begins a comment that ends with the end of the current line, </p></li><li><p>the delimiters <code>/*</code> and <code>*/</code> respectively start and end a comment, which can be found in the middle of a command or span several lines. </p></li></ul><p>Any place where you could enter a <em>whitespace</em> will accept a comment too. </p><h3>Batch behaviour options</h3><p>All pgloader commands have support for a <em>WITH</em> clause that allows for specifying options. Some options are generic and accepted by all commands, such as the <em>batch behaviour options</em>, and some options are specific to a data source kind, such as the CSV <em>skip header</em> option. </p><p>The global batch behaviour options are: </p><ul><li><em>batch rows</em><p>Takes a numeric value as argument, used as the maximum number of rows allowed in a batch. The default is <code>25 000</code> and can be changed to try having better performance characteristics or to control pgloader memory usage; </p></li><li><em>batch size</em><p>Takes a memory unit as argument, such as <em>20 MB</em>, its default value. Accepted multipliers are <em>kB</em>, <em>MB</em>, <em>GB</em>, <em>TB</em> and <em>PB</em>. The case is important so as not to be confused about bits versus bytes, we're only talking bytes here. </p></li><li><em>prefetch rows</em><p>Takes a numeric value as argument, defaults to <code>100000</code>. That's the number of rows that pgloader is allowed to read in memory in each reader thread. See the <em>workers</em> setting for how many reader threads are allowed to run at the same time. </p></li></ul><p>Other options are specific to each input source, please refer to specific parts of the documentation for their listing and covering. </p><p>A batch is then closed as soon as either the <em>batch rows</em> or the <em>batch size</em> threshold is crossed, whichever comes first. In cases when a batch has to be closed because of the <em>batch size</em> setting, a <em>debug</em> level log message is printed with how many rows did fit in the <em>oversized</em> batch. </p><h2>LOAD CSV</h2><p>This command instructs pgloader to load data from a <code>CSV</code> file. Here's an example: </p><pre><code>LOAD CSV  
   FROM 'GeoLiteCity-Blocks.csv' WITH ENCODING iso-646-us  
        HAVING FIELDS  
        (  
           startIpNum, endIpNum, locId  
        )  
   INTO postgresql://user@localhost:54393/dbname?geolite.blocks  
        TARGET COLUMNS  
        (  
           iprange ip4r using (ip-range startIpNum endIpNum),  
           locId  
        )  
   WITH truncate,  
        skip header = 2,  
        fields optionally enclosed by '"',  
        fields escaped by backslash-quote,  
        fields terminated by '\t'  
 
    SET work_mem to '32 MB', maintenance_work_mem to '64 MB'; </code></pre><p>The <code>csv</code> format command accepts the following clauses and options: </p><ul><li><em>FROM</em><p>Filename where to load the data from. Accepts an <em>ENCODING</em> option. Use the <code>--list-encodings</code> option to know which encoding names are supported. </p></li><p>The filename may be enclosed by single quotes, and could be one of the following special values: </p><ul><li><em>inline</em><p>The data is found after the end of the parsed commands. Any number of empty lines between the end of the commands and the beginning of the data is accepted. </p></li><li><em>stdin</em><p>Reads the data from the standard input stream. </p></li><li><em>FILENAMES MATCHING</em><p>The whole <em>matching</em> clause must follow the following rule: </p><pre><code>[ ALL FILENAMES | [ FIRST ] FILENAME ]  
MATCHING regexp  
[ IN DIRECTORY '...' ] </code></pre></li><p>The <em>matching</em> clause applies given <em>regular expression</em> (see above for exact syntax, several options can be used here) to filenames. It's then possible to load data from only the first match of all of them. </p><p>The optional <em>IN DIRECTORY</em> clause allows specifying which directory to walk for finding the data files, and can be either relative to where the command file is read from, or absolute. The given directory must exists. </p></ul><p>The <em>FROM</em> option also supports an optional comma separated list of <em>field</em> names describing what is expected in the <code>CSV</code> data file, optionally introduced by the clause <code>HAVING FIELDS</code>. </p><p>Each field name can be either only one name or a name following with specific reader options for that field, enclosed in square brackets and comma-separated. Supported per-field reader options are: </p><ul><li><em>terminated by</em><p>See the description of <em>field terminated by</em> below. </p></li><p>The processing of this option is not currently implemented. </p><li><em>date format</em></li><p>When the field is expected of the date type, then this option allows to specify the date format used in the file. </p><p>Date format string are template strings modeled against the PostgreSQL <code>to_char</code> template strings support, limited to the following patterns: </p><ul><li>YYYY, YYY, YY for the year part</li><li>MM for the numeric month part</li><li>DD for the numeric day part</li><li>HH, HH12, HH24 for the hour part</li><li>am, AM, a.m., A.M.</li><li>pm, PM, p.m., P.M.</li><li>MI for the minutes part</li><li>SS for the seconds part</li><li>MS for the milliseconds part (4 digits)</li><li>US for the microseconds part (6 digits)</li><li>unparsed punctuation signs: - . * # @ T / \ and space</li></ul><p>Here's an example of a <em>date format</em> specification: </p><pre><code>column-name [date format 'YYYY-MM-DD HH24-MI-SS.US'] </code></pre><li><em>null if</em><p>This option takes an argument which is either the keyword <em>blanks</em> or a double-quoted string. </p></li><p>When <em>blanks</em> is used and the field value that is read contains only space characters, then it's automatically converted to an SQL <code>NULL</code> value. </p><p>When a double-quoted string is used and that string is read as the field value, then the field value is automatically converted to an SQL <code>NULL</code> value. </p><li><em>trim both whitespace</em>, <em>trim left whitespace</em>, <em>trim right whitespace</em><p>This option allows to trim whitespaces in the read data, either from both sides of the data, or only the whitespace characters found on the left of the streaing, or only those on the right of the string. </p></li></ul><li><em>WITH</em><p>When loading from a <code>CSV</code> file, the following options are supported: </p><ul><li><em>truncate</em><p>When this option is listed, pgloader issues a <code>TRUNCATE</code> command against the PostgreSQL target table before reading the data file. </p></li><li><em>drop indexes</em><p>When this option is listed, pgloader issues <code>DROP INDEX</code> commands against all the indexes defined on the target table before copying the data, then <code>CREATE INDEX</code> commands once the <code>COPY</code> is done. </p></li><p>In order to get the best performance possible, all the indexes are created in parallel and when done the primary keys are built again from the unique indexes just created. This two step process allows creating the primary key index in parallel with the other indexes, as only the <code>ALTER TABLE</code> command needs an <em>access exclusive lock</em> on the target table. </p><li><em>disable triggers</em></li><p>When this option is listed, pgloader issues an <code>ALTER TABLE ... DISABLE TRIGGER ALL</code> command against the PostgreSQL target table before copying the data, then the command <code>ALTER TABLE ... ENABLE TRIGGER ALL</code> once the <code>COPY</code> is done. </p><p>This option allows loading data into a pre-existing table ignoring the <em>foreign key constraints</em> and user defined triggers and may result in invalid <em>foreign key constraints</em> once the data is loaded. Use with care. </p><li><em>skip header</em><p>Takes a numeric value as argument. Instruct pgloader to skip that many lines at the beginning of the input file. </p></li><li><em>csv header</em><p>Use the first line read after <em>skip header</em> as the list of csv field names to be found in the CSV file, using the same CSV parameters as for the CSV data. </p></li><li><em>trim unquoted blanks</em><p>When reading unquoted values in the <code>CSV</code> file, remove the blanks found in between the separator and the value. That behaviour is the default. </p></li><li><em>keep unquoted blanks</em><p>When reading unquoted values in the <code>CSV</code> file, keep blanks found in between the separator and the value. </p></li><li><em>fields optionally enclosed by</em><p>Takes a single character as argument, which must be found inside single quotes, and might be given as the printable character itself, the special value \t to denote a tabulation character, or <code>0x</code> then an hexadecimal value read as the ASCII code for the character. </p></li><p>This character is used as the quoting character in the <code>CSV</code> file, and defaults to double-quote. </p><li><em>fields not enclosed</em></li><p>By default, pgloader will use the double-quote character as the enclosing character. If you have a CSV file where fields are not enclosed and are using double-quote as an expected ordinary character, then use the option <em>fields not enclosed</em> for the CSV parser to accept those values. </p><li><em>fields escaped by</em></li><p>Takes either the special value <em>backslash-quote</em> or <em>double-quote</em>, or any value supported by the <em>fields terminated by</em> option (see below). This value is used to recognize escaped field separators when they are to be found within the data fields themselves. Defaults to <em>double-quote</em>. </p><li><em>csv escape mode</em></li><p>Takes either the special value <em>quote</em> (the default) or <em>following</em> and allows the CSV parser to parse either only escaped field separator or any character (including CSV data) when using the <em>following</em> value. </p><li><em>fields terminated by</em></li><p>Takes a single character as argument, which must be found inside single quotes, and might be given as the printable character itself, the special value \t to denote a tabulation character, or <code>0x</code> then an hexadecimal value read as the ASCII code for the character. </p><p>This character is used as the <em>field separator</em> when reading the <code>CSV</code> data. </p><li><em>lines terminated by</em><p>Takes a single character as argument, which must be found inside single quotes, and might be given as the printable character itself, the special value \t to denote a tabulation character, or <code>0x</code> then an hexadecimal value read as the ASCII code for the character. </p></li><p>This character is used to recognize <em>end-of-line</em> condition when reading the <code>CSV</code> data. </p></ul></li></ul><h2>LOAD FIXED COLS</h2><p>This command instructs pgloader to load data from a text file containing columns arranged in a <em>fixed size</em> manner. Here's an example: </p><pre><code>LOAD FIXED  
     FROM inline  
          (  
           a from  0 for 10,  
           b from 10 for  8,  
           c from 18 for  8,  
           d from 26 for 17 [null if blanks, trim right whitespace]  
          )  
     INTO postgresql:///pgloader?fixed  
          (  
             a, b,  
             c time using (time-with-no-separator c),  
             d  
          )  
 
     WITH truncate  
 
      SET work_mem to '14MB',  
          standard_conforming_strings to 'on'  
 
BEFORE LOAD DO  
     $$ drop table if exists fixed; $$,  
     $$ create table fixed (  
         a integer,  
         b date,  
         c time,  
         d text  
        );  
     $$;  
 
 01234567892008052011431250firstline  
    01234562008052115182300left blank-padded  
 12345678902008052208231560another line  
  2345609872014092914371500                  
  2345678902014092914371520 </code></pre><p>The <code>fixed</code> format command accepts the following clauses and options: </p><ul><li><em>FROM</em><p>Filename where to load the data from. Accepts an <em>ENCODING</em> option. Use the <code>--list-encodings</code> option to know which encoding names are supported. </p></li><p>The filename may be enclosed by single quotes, and could be one of the following special values: </p><ul><li><em>inline</em><p>The data is found after the end of the parsed commands. Any number of empty lines between the end of the commands and the beginning of the data is accepted. </p></li><li><em>stdin</em><p>Reads the data from the standard input stream. </p></li><li><em>FILENAMES MATCHING</em><p>The whole <em>matching</em> clause must follow the following rule: </p><pre><code>[ ALL FILENAMES | [ FIRST ] FILENAME ]  
MATCHING regexp  
[ IN DIRECTORY '...' ] </code></pre></li><p>The <em>matching</em> clause applies given <em>regular expression</em> (see above for exact syntax, several options can be used here) to filenames. It's then possible to load data from only the first match of all of them. </p><p>The optional <em>IN DIRECTORY</em> clause allows specifying which directory to walk for finding the data files, and can be either relative to where the command file is read from, or absolute. The given directory must exists. </p></ul><p>The <em>FROM</em> option also supports an optional comma separated list of <em>field</em> names describing what is expected in the <code>FIXED</code> data file. </p><p>Each field name is composed of the field name followed with specific reader options for that field. Supported per-field reader options are the following, where only <em>start</em> and <em>length</em> are required. </p><ul><li><em>start</em><p>Position in the line where to start reading that field's value. Can be entered with decimal digits or <code>0x</code> then hexadecimal digits. </p></li><li><em>length</em><p>How many bytes to read from the <em>start</em> position to read that field's value. Same format as <em>start</em>. </p></li></ul><p>Those optional parameters must be enclosed in square brackets and comma-separated: </p><ul><li><em>terminated by</em><p>See the description of <em>field terminated by</em> below. </p></li><p>The processing of this option is not currently implemented. </p><li><em>date format</em></li><p>When the field is expected of the date type, then this option allows to specify the date format used in the file. </p><p>Date format string are template strings modeled against the PostgreSQL <code>to_char</code> template strings support, limited to the following patterns: </p><ul><li>YYYY, YYY, YY for the year part</li><li>MM for the numeric month part</li><li>DD for the numeric day part</li><li>HH, HH12, HH24 for the hour part</li><li>am, AM, a.m., A.M.</li><li>pm, PM, p.m., P.M.</li><li>MI for the minutes part</li><li>SS for the seconds part</li><li>MS for the milliseconds part (4 digits)</li><li>US for the microseconds part (6 digits)</li><li>unparsed punctuation signs: - . * # @ T / \ and space</li></ul><p>Here's an example of a <em>date format</em> specification: </p><pre><code>column-name [date format 'YYYY-MM-DD HH24-MI-SS.US'] </code></pre><li><em>null if</em><p>This option takes an argument which is either the keyword <em>blanks</em> or a double-quoted string. </p></li><p>When <em>blanks</em> is used and the field value that is read contains only space characters, then it's automatically converted to an SQL <code>NULL</code> value. </p><p>When a double-quoted string is used and that string is read as the field value, then the field value is automatically converted to an SQL <code>NULL</code> value. </p><li><em>trim both whitespace</em>, <em>trim left whitespace</em>, <em>trim right whitespace</em><p>This option allows to trim whitespaces in the read data, either from both sides of the data, or only the whitespace characters found on the left of the streaing, or only those on the right of the string. </p></li></ul><li><em>WITH</em><p>When loading from a <code>FIXED</code> file, the following options are supported: </p><ul><li><em>truncate</em><p>When this option is listed, pgloader issues a <code>TRUNCATE</code> command against the PostgreSQL target table before reading the data file. </p></li><li><em>disable triggers</em><p>When this option is listed, pgloader issues an <code>ALTER TABLE ... DISABLE TRIGGER ALL</code> command against the PostgreSQL target table before copying the data, then the command <code>ALTER TABLE ... ENABLE TRIGGER ALL</code> once the <code>COPY</code> is done. </p></li><p>This option allows loading data into a pre-existing table ignoring the <em>foreign key constraints</em> and user defined triggers and may result in invalid <em>foreign key constraints</em> once the data is loaded. Use with care. </p><li><em>skip header</em></li><p>Takes a numeric value as argument. Instruct pgloader to skip that many lines at the beginning of the input file. </p></ul></li></ul><h2>LOAD COPY FORMATTED FILES</h2><p>This commands instructs pgloader to load from a file containing COPY TEXT data as described in the PostgreSQL documentation. Here's an example: </p><pre><code>LOAD COPY  
     FROM copy://./data/track.copy  
          (  
            trackid, track, album, media, genre, composer,  
            milliseconds, bytes, unitprice  
          )  
     INTO postgresql:///pgloader?track_full  
 
     WITH truncate  
 
      SET work_mem to '14MB',  
          standard_conforming_strings to 'on'  
 
BEFORE LOAD DO  
     $$ drop table if exists track_full; $$,  
     $$ create table track_full (  
          trackid      bigserial,  
          track        text,  
          album        text,  
          media        text,  
          genre        text,  
          composer     text,  
          milliseconds bigint,  
          bytes        bigint,  
          unitprice    numeric  
        );  
     $$; </code></pre><p>The <code>COPY</code> format command accepts the following clauses and options: </p><ul><li><em>FROM</em><p>Filename where to load the data from. This support local files, HTTP URLs and zip files containing a single dbf file of the same name. Fetch such a zip file from an HTTP address is of course supported. </p><ul><li><em>inline</em><p>The data is found after the end of the parsed commands. Any number of empty lines between the end of the commands and the beginning of the data is accepted. </p></li><li><em>stdin</em><p>Reads the data from the standard input stream. </p></li><li><em>FILENAMES MATCHING</em><p>The whole <em>matching</em> clause must follow the following rule: </p><pre><code>[ ALL FILENAMES | [ FIRST ] FILENAME ]  
MATCHING regexp  
[ IN DIRECTORY '...' ] </code></pre></li><p>The <em>matching</em> clause applies given <em>regular expression</em> (see above for exact syntax, several options can be used here) to filenames. It's then possible to load data from only the first match of all of them. </p><p>The optional <em>IN DIRECTORY</em> clause allows specifying which directory to walk for finding the data files, and can be either relative to where the command file is read from, or absolute. The given directory must exists. </p></ul></li><li><em>WITH</em><p>When loading from a <code>COPY</code> file, the following options are supported: </p><ul><li><em>delimiter</em><p>Takes a single character as argument, which must be found inside single quotes, and might be given as the printable character itself, the special value \t to denote a tabulation character, or <code>0x</code> then an hexadecimal value read as the ASCII code for the character. </p></li><p>This character is used as the <em>delimiter</em> when reading the data, in a similar way to the PostgreSQL <code>COPY</code> option. </p><li><em>null</em></li><p>Takes a quoted string as an argument (quotes can be either double quotes or single quotes) and uses that string as the <code>NULL</code> representation in the data. </p><p>This is similar to the <em>null</em> <code>COPY</code> option in PostgreSQL. </p><li><em>truncate</em><p>When this option is listed, pgloader issues a <code>TRUNCATE</code> command against the PostgreSQL target table before reading the data file. </p></li><li><em>disable triggers</em><p>When this option is listed, pgloader issues an <code>ALTER TABLE ... DISABLE TRIGGER ALL</code> command against the PostgreSQL target table before copying the data, then the command <code>ALTER TABLE ... ENABLE TRIGGER ALL</code> once the <code>COPY</code> is done. </p></li><p>This option allows loading data into a pre-existing table ignoring the <em>foreign key constraints</em> and user defined triggers and may result in invalid <em>foreign key constraints</em> once the data is loaded. Use with care. </p><li><em>skip header</em></li><p>Takes a numeric value as argument. Instruct pgloader to skip that many lines at the beginning of the input file. </p></ul></li></ul><h2>LOAD DBF</h2><p>This command instructs pgloader to load data from a <code>DBF</code> file. Here's an example: </p><pre><code>LOAD DBF  
    FROM http://www.insee.fr/fr/methodes/nomenclatures/cog/telechargement/2013/dbf/reg2013.dbf  
    INTO postgresql://user@localhost/dbname  
    WITH truncate, create table; </code></pre><p>The <code>dbf</code> format command accepts the following clauses and options: </p><ul><li><em>FROM</em><p>Filename where to load the data from. This support local files, HTTP URLs and zip files containing a single dbf file of the same name. Fetch such a zip file from an HTTP address is of course supported. </p></li><li><em>WITH</em><p>When loading from a <code>DBF</code> file, the following options are supported: </p><ul><li><em>truncate</em><p>When this option is listed, pgloader issues a <code>TRUNCATE</code> command against the PostgreSQL target table before reading the data file. </p></li><li><em>disable triggers</em><p>When this option is listed, pgloader issues an <code>ALTER TABLE ... DISABLE TRIGGER ALL</code> command against the PostgreSQL target table before copying the data, then the command <code>ALTER TABLE ... ENABLE TRIGGER ALL</code> once the <code>COPY</code> is done. </p></li><p>This option allows loading data into a pre-existing table ignoring the <em>foreign key constraints</em> and user defined triggers and may result in invalid <em>foreign key constraints</em> once the data is loaded. Use with care. </p><li><em>create table</em></li><p>When this option is listed, pgloader creates the table using the meta data found in the <code>DBF</code> file, which must contain a list of fields with their data type. A standard data type conversion from DBF to PostgreSQL is done. </p><li><em>table name</em></li><p>This options expects as its value the possibly qualified name of the table to create. </p></ul></li></ul><h2>LOAD IXF</h2><p>This command instructs pgloader to load data from an IBM <code>IXF</code> file. Here's an example: </p><pre><code>LOAD IXF  
    FROM data/nsitra.test1.ixf  
    INTO postgresql:///pgloader?nsitra.test1  
    WITH truncate, create table, timezone UTC  
 
  BEFORE LOAD DO  
   $$ create schema if not exists nsitra; $$,  
   $$ drop table if exists nsitra.test1; $$; </code></pre><p>The <code>ixf</code> format command accepts the following clauses and options: </p><ul><li><em>FROM</em><p>Filename where to load the data from. This support local files, HTTP URLs and zip files containing a single ixf file of the same name. Fetch such a zip file from an HTTP address is of course supported. </p></li><li><em>WITH</em><p>When loading from a <code>IXF</code> file, the following options are supported: </p><ul><li><em>truncate</em><p>When this option is listed, pgloader issues a <code>TRUNCATE</code> command against the PostgreSQL target table before reading the data file. </p></li><li><em>disable triggers</em><p>When this option is listed, pgloader issues an <code>ALTER TABLE ... DISABLE TRIGGER ALL</code> command against the PostgreSQL target table before copying the data, then the command <code>ALTER TABLE ... ENABLE TRIGGER ALL</code> once the <code>COPY</code> is done. </p></li><p>This option allows loading data into a pre-existing table ignoring the <em>foreign key constraints</em> and user defined triggers and may result in invalid <em>foreign key constraints</em> once the data is loaded. Use with care. </p><li><em>create table</em></li><p>When this option is listed, pgloader creates the table using the meta data found in the <code>DBF</code> file, which must contain a list of fields with their data type. A standard data type conversion from DBF to PostgreSQL is done. </p><li><em>table name</em></li><p>This options expects as its value the possibly qualified name of the table to create. </p><li><em>timezone</em></li><p>This options allows to specify which timezone is used when parsing timestamps from an IXF file, and defaults to <em>UTC</em>. Expected values are either <code>UTC</code>, <code>GMT</code> or a single quoted location name such as <code>'Universal'</code> or <code>'Europe/Paris'</code>. </p></ul></li></ul><h2>LOAD ARCHIVE</h2><p>This command instructs pgloader to load data from one or more files contained in an archive. Currently the only supported archive format is <em>ZIP</em>, and the archive might be downloaded from an <em>HTTP</em> URL. </p><p>Here's an example: </p><pre><code>LOAD ARCHIVE  
   FROM /Users/dim/Downloads/GeoLiteCity-latest.zip  
   INTO postgresql:///ip4r  
 
   BEFORE LOAD  
     DO $$ create extension if not exists ip4r; $$,  
        $$ create schema if not exists geolite; $$,  
 
     EXECUTE 'geolite.sql'  
 
   LOAD CSV  
        FROM FILENAME MATCHING ~/GeoLiteCity-Location.csv/  
             WITH ENCODING iso-8859-1  
             (  
                locId,  
                country,  
                region     null if blanks,  
                city       null if blanks,  
                postalCode null if blanks,  
                latitude,  
                longitude,  
                metroCode  null if blanks,  
                areaCode   null if blanks  
             )  
        INTO postgresql:///ip4r?geolite.location  
             (  
                locid,country,region,city,postalCode,  
                location point using (format nil "(~a,~a)" longitude latitude),  
                metroCode,areaCode  
             )  
        WITH skip header = 2,  
             fields optionally enclosed by '"',  
             fields escaped by double-quote,  
             fields terminated by ','  
 
  AND LOAD CSV  
        FROM FILENAME MATCHING ~/GeoLiteCity-Blocks.csv/  
             WITH ENCODING iso-8859-1  
             (  
                startIpNum, endIpNum, locId  
             )  
        INTO postgresql:///ip4r?geolite.blocks  
             (  
                iprange ip4r using (ip-range startIpNum endIpNum),  
                locId  
             )  
        WITH skip header = 2,  
             fields optionally enclosed by '"',  
             fields escaped by double-quote,  
             fields terminated by ','  
 
   FINALLY DO  
     $$ create index blocks_ip4r_idx on geolite.blocks using gist(iprange); $$; </code></pre><p>The <code>archive</code> command accepts the following clauses and options: </p><ul><li><em>FROM</em><p> Filename or HTTP URI where to load the data from. When given an HTTP  URL the linked file will get downloaded locally before processing. </p></li><p> If the file is a <code>zip</code> file, the command line utility <code>unzip</code> is used  to expand the archive into files in <code>$TMPDIR</code>, or <code>/tmp</code> if <code>$TMPDIR</code>  is unset or set to a non-existing directory. </p><p> Then the following commands are used from the top level directory where  the archive has been expanded. </p><li>command [ <em>AND</em> command ... ]<p> A series of commands against the contents of the archive, at the moment  only <code>CSV</code>,<code>'FIXED</code> and <code>DBF</code> commands are supported. </p></li><p> Note that commands are supporting the clause <em>FROM FILENAME MATCHING</em>  which allows the pgloader command not to depend on the exact names of  the archive directories. </p><p> The same clause can also be applied to several files with using the  spelling <em>FROM ALL FILENAMES MATCHING</em> and a regular expression. </p><p> The whole <em>matching</em> clause must follow the following rule: </p><pre><code> FROM [ ALL FILENAMES | [ FIRST ] FILENAME ] MATCHING </code></pre><li><em>FINALLY DO</em><p> SQL Queries to run once the data is loaded, such as <code>CREATE INDEX</code>. </p></li></ul><h2>LOAD MYSQL DATABASE</h2><p>This command instructs pgloader to load data from a database connection. The only supported database source is currently <em>MySQL</em>, and pgloader supports dynamically converting the schema of the source database and the indexes building. </p><p>A default set of casting rules are provided and might be overloaded and appended to by the command. </p><p>Here's an example using as many options as possible, some of them even being defaults. Chances are you don't need that complex a setup, don't copy and paste it, use it only as a reference! </p><pre><code>LOAD DATABASE  
     FROM      mysql://root@localhost/sakila  
     INTO postgresql://localhost:54393/sakila  
 
 WITH include drop, create tables, create indexes, reset sequences,  
      workers = 8, concurrency = 1,  
      multiple readers per thread, rows per range = 50000  
 
  SET PostgreSQL PARAMETERS  
      maintenance_work_mem to '128MB',  
      work_mem to '12MB',  
      search_path to 'sakila, public, "$user"'  
 
  SET MySQL PARAMETERS  
      net_read_timeout  = '120',  
      net_write_timeout = '120'  
 
 CAST type bigint when (= precision 20) to bigserial drop typemod,  
      type date drop not null drop default using zero-dates-to-null,  
      -- type tinyint to boolean using tinyint-to-boolean,  
      type year to integer  
 
 MATERIALIZE VIEWS film_list, staff_list  
 
 -- INCLUDING ONLY TABLE NAMES MATCHING ~/film/, 'actor'  
 -- EXCLUDING TABLE NAMES MATCHING ~&lt;ory&gt;  
 -- DECODING TABLE NAMES MATCHING ~/messed/, ~/encoding/ AS utf8  
 -- ALTER TABLE NAMES MATCHING 'film' RENAME TO 'films'  
 -- ALTER TABLE NAMES MATCHING ~/_list$/ SET SCHEMA 'mv'  
 
 ALTER TABLE NAMES MATCHING ~/_list$/, 'sales_by_store', ~/sales_by/  
  SET SCHEMA 'mv'  
 
 ALTER TABLE NAMES MATCHING 'film' RENAME TO 'films'  
 ALTER TABLE NAMES MATCHING ~/./ SET (fillfactor='40')  
 
 ALTER SCHEMA 'sakila' RENAME TO 'pagila'  
 
 BEFORE LOAD DO  
   $$ create schema if not exists pagila; $$,  
   $$ create schema if not exists mv;     $$,  
   $$ alter database sakila set search_path to pagila, mv, public; $$;  
</code></pre><p>The <code>database</code> command accepts the following clauses and options: </p><ul><li><em>FROM</em><p>Must be a connection URL pointing to a MySQL database. </p></li><p>If the connection URI contains a table name, then only this table is migrated from MySQL to PostgreSQL. </p><p>See the <code>SOURCE CONNECTION STRING</code> section above for details on how to write the connection string. Environment variables described in <http://dev.mysql.com/doc/refman/5.0/en/environment-variables.html>  can be used as default values too. If the user is not provided, then it defaults to <code>USER</code> environment variable value. The password can be provided with the environment variable <code>MYSQL_PWD</code>. The host can be provided with the environment variable <code>MYSQL_HOST</code> and otherwise defaults to <code>localhost</code>. The port can be provided with the environment variable <code>MYSQL_TCP_PORT</code> and otherwise defaults to <code>3306</code>. </p><li><em>WITH</em><p>When loading from a <code>MySQL</code> database, the following options are supported, and the default <em>WITH</em> clause is: <em>no truncate</em>, <em>create schema</em>, <em>create tables</em>, <em>include drop</em>, <em>create indexes</em>, <em>reset sequences</em>, <em>foreign keys</em>, <em>downcase identifiers</em>, <em>uniquify index names</em>. </p></li><p><em>WITH</em> options: </p><ul><li><em>include drop</em><p>When this option is listed, pgloader drops all the tables in the target PostgreSQL database whose names appear in the MySQL database. This option allows for using the same command several times in a row until you figure out all the options, starting automatically from a clean environment. Please note that <code>CASCADE</code> is used to ensure that tables are dropped even if there are foreign keys pointing to them. This is precisely what <code>include drop</code> is intended to do: drop all target tables and recreate them. </p></li><p>Great care needs to be taken when using <code>include drop</code>, as it will cascade to <em>all</em> objects referencing the target tables, possibly including other tables that are not being loaded from the source DB. </p><li><em>include no drop</em></li><p>When this option is listed, pgloader will not include any <code>DROP</code> statement when loading the data. </p><li><em>truncate</em></li><p>When this option is listed, pgloader issue the <code>TRUNCATE</code> command against each PostgreSQL table just before loading data into it. </p><li><em>no truncate</em></li><p>When this option is listed, pgloader issues no <code>TRUNCATE</code> command. </p><li><em>disable triggers</em></li><p>When this option is listed, pgloader issues an <code>ALTER TABLE ... DISABLE TRIGGER ALL</code> command against the PostgreSQL target table before copying the data, then the command <code>ALTER TABLE ... ENABLE TRIGGER ALL</code> once the <code>COPY</code> is done. </p><p>This option allows loading data into a pre-existing table ignoring the <em>foreign key constraints</em> and user defined triggers and may result in invalid <em>foreign key constraints</em> once the data is loaded. Use with care. </p><li><em>create tables</em><p>When this option is listed, pgloader creates the table using the meta data found in the <code>MySQL</code> file, which must contain a list of fields with their data type. A standard data type conversion from DBF to PostgreSQL is done. </p></li><li><em>create no tables</em><p>When this option is listed, pgloader skips the creation of table before loading data, target tables must then already exist. </p></li><p>Also, when using <em>create no tables</em> pgloader fetches the metadata from the current target database and checks type casting, then will remove constraints and indexes prior to loading the data and install them back again once the loading is done. </p><li><em>create indexes</em></li><p>When this option is listed, pgloader gets the definitions of all the indexes found in the MySQL database and create the same set of index definitions against the PostgreSQL database. </p><li><em>create no indexes</em></li><p>When this option is listed, pgloader skips the creating indexes. </p><li><em>drop indexes</em></li><p>When this option is listed, pgloader drops the indexes in the target database before loading the data, and creates them again at the end of the data copy. </p><li><em>uniquify index names</em>, <em>preserve index names</em></li><p>MySQL index names are unique per-table whereas in PostgreSQL index names have to be unique per-schema. The default for pgloader is to change the index name by prefixing it with <code>idx_OID</code> where <code>OID</code> is the internal numeric identifier of the table the index is built against. </p><p>In somes cases like when the DDL are entirely left to a framework it might be sensible for pgloader to refrain from handling index unique names, that is achieved by using the <em>preserve index names</em> option. </p><p>The default is to <em>uniquify index names</em>. </p><p>Even when using the option <em>preserve index names</em>, MySQL primary key indexes named "PRIMARY" will get their names uniquified. Failing to do so would prevent the primary keys to be created again in PostgreSQL where the index names must be unique per schema. </p><li><em>foreign keys</em><p>When this option is listed, pgloader gets the definitions of all the foreign keys found in the MySQL database and create the same set of foreign key definitions against the PostgreSQL database. </p></li><li><em>no foreign keys</em><p>When this option is listed, pgloader skips creating foreign keys. </p></li><li><em>reset sequences</em><p>When this option is listed, at the end of the data loading and after the indexes have all been created, pgloader resets all the PostgreSQL sequences created to the current maximum value of the column they are attached to. </p></li><p>The options <em>schema only</em> and <em>data only</em> have no effects on this option. </p><li><em>reset no sequences</em></li><p>When this option is listed, pgloader skips resetting sequences after the load. </p><p>The options <em>schema only</em> and <em>data only</em> have no effects on this option. </p><li><em>downcase identifiers</em><p>When this option is listed, pgloader converts all MySQL identifiers (table names, index names, column names) to <em>downcase</em>, except for PostgreSQL <em>reserved</em> keywords. </p></li><p>The PostgreSQL <em>reserved</em> keywords are determined dynamically by using the system function <code>pg_get_keywords()</code>. </p><li><em>quote identifiers</em></li><p>When this option is listed, pgloader quotes all MySQL identifiers so that their case is respected. Note that you will then have to do the same thing in your application code queries. </p><li><em>schema only</em></li><p>When this option is listed pgloader refrains from migrating the data over. Note that the schema in this context includes the indexes when the option <em>create indexes</em> has been listed. </p><li><em>data only</em></li><p>When this option is listed pgloader only issues the <code>COPY</code> statements, without doing any other processing. </p><li><em>single reader per thread</em>, <em>multiple readers per thread</em></li><p>The default is <em>single reader per thread</em> and it means that each MySQL table is read by a single thread as a whole, with a single <code>SELECT</code> statement using no <code>WHERE</code> clause. </p><p>When using <em>multiple readers per thread</em> pgloader may be able to divide the reading work into several threads, as many as the <em>concurrency</em> setting, which needs to be greater than 1 for this option to kick be activated. </p><p>For each source table, pgloader searches for a primary key over a single numeric column, or a multiple-column primary key index for which the first column is of a numeric data type (one of <code>integer</code> or <code>bigint</code>). When such an index exists, pgloader runs a query to find the <em>min</em> and <em>max</em> values on this column, and then split that range into many ranges containing a maximum of <em>rows per range</em>. </p><p>When the range list we then obtain contains at least as many ranges than our concurrency setting, then we distribute those ranges to each reader thread. </p><p>So when all the conditions are met, pgloader then starts as many reader thread as the <em>concurrency</em> setting, and each reader thread issues several queries with a <code>WHERE id &gt;= x AND id &lt; y</code>, where <code>y - x = rows per range</code> or less (for the last range, depending on the max value just obtained. </p><li><em>rows per range</em><p>How many rows are fetched per <code>SELECT</code> query when using <em>multiple readers per thread</em>, see above for details. </p></li></ul><li><em>SET MySQL PARAMETERS</em><p>The <em>SET MySQL PARAMETERS</em> allows setting MySQL parameters using the MySQL <code>SET</code> command each time pgloader connects to it. </p></li><li><em>CAST</em><p>The cast clause allows to specify custom casting rules, either to overload the default casting rules or to amend them with special cases. </p></li><p>A casting rule is expected to follow one of the forms: </p><pre><code>type &lt;mysql-type-name&gt; [ &lt;guard&gt; ... ] to &lt;pgsql-type-name&gt; [ &lt;option&gt; ... ]  
column &lt;table-name&gt;.&lt;column-name&gt; [ &lt;guards&gt; ] to ... </code></pre><p>It's possible for a <em>casting rule</em> to either match against a MySQL data type or against a given <em>column name</em> in a given <em>table name</em>. That flexibility allows to cope with cases where the type <code>tinyint</code> might have been used as a <code>boolean</code> in some cases but as a <code>smallint</code> in others. </p><p>The <em>casting rules</em> are applied in order, the first match prevents following rules to be applied, and user defined rules are evaluated first. </p><p>The supported guards are: </p><ul><li><em>when default 'value'</em><p>The casting rule is only applied against MySQL columns of the source type that have given <em>value</em>, which must be a single-quoted or a double-quoted string. </p></li><li><em>when typemod expression</em><p>The casting rule is only applied against MySQL columns of the source type that have a <em>typemod</em> value matching the given <em>typemod expression</em>. The <em>typemod</em> is separated into its <em>precision</em> and <em>scale</em> components. </p></li><p>Example of a cast rule using a <em>typemod</em> guard: </p><pre><code>type char when (= precision 1) to char keep typemod </code></pre><p>This expression casts MySQL <code>char(1)</code> column to a PostgreSQL column of type <code>char(1)</code> while allowing for the general case <code>char(N)</code> will be converted by the default cast rule into a PostgreSQL type <code>varchar(N)</code>. </p><li><em>with extra auto_increment</em></li><p>The casting rule is only applied against MySQL columns having the <em>extra</em> column <code>auto_increment</code> option set, so that it's possible to target e.g. <code>serial</code> rather than <code>integer</code>. </p><p>The default matching behavior, when this option isn't set, is to match both columns with the extra definition and without. </p><p>This means that if you want to implement a casting rule that target either <code>serial</code> or <code>integer</code> from a <code>smallint</code> definition depending on the <em>auto_increment</em> extra bit of information from MySQL, then you need to spell out two casting rules as following: </p><pre><code>type smallint  with extra auto_increment  
  to serial drop typemod keep default keep not null,  
type smallint  
  to integer drop typemod keep default keep not null </code></pre></ul><p>The supported casting options are: </p><ul><li><em>drop default</em>, <em>keep default</em><p>When the option <em>drop default</em> is listed, pgloader drops any existing default expression in the MySQL database for columns of the source type from the <code>CREATE TABLE</code> statement it generates. </p></li><p>The spelling <em>keep default</em> explicitly prevents that behaviour and can be used to overload the default casting rules. </p><li><em>drop not null</em>, <em>keep not null</em>, <em>set not null</em></li><p>When the option <em>drop not null</em> is listed, pgloader drops any existing <code>NOT NULL</code> constraint associated with the given source MySQL datatype when it creates the tables in the PostgreSQL database. </p><p>The spelling <em>keep not null</em> explicitly prevents that behaviour and can be used to overload the default casting rules. </p><p>When the option <em>set not null</em> is listed, pgloader sets a <code>NOT NULL</code> constraint on the target column regardless whether it has been set in the source MySQL column. </p><li><em>drop typemod</em>, <em>keep typemod</em><p>When the option <em>drop typemod</em> is listed, pgloader drops any existing <em>typemod</em> definition (e.g. <em>precision</em> and <em>scale</em>) from the datatype definition found in the MySQL columns of the source type when it created the tables in the PostgreSQL database. </p></li><p>The spelling <em>keep typemod</em> explicitly prevents that behaviour and can be used to overload the default casting rules. </p><li><em>using</em></li><p>This option takes as its single argument the name of a function to be found in the <code>pgloader.transforms</code> Common Lisp package. See above for details. </p><p>It's possible to augment a default cast rule (such as one that applies against <code>ENUM</code> data type for example) with a <em>transformation function</em> by omitting entirely the <code>type</code> parts of the casting rule, as in the following example: </p><pre><code>column enumerate.foo using empty-string-to-null </code></pre></ul><li><em>MATERIALIZE VIEWS</em><p>This clause allows you to implement custom data processing at the data source by providing a <em>view definition</em> against which pgloader will query the data. It's not possible to just allow for plain <code>SQL</code> because we want to know a lot about the exact data types of each column involved in the query output. </p></li><p>This clause expect a comma separated list of view definitions, each one being either the name of an existing view in your database or the following expression: </p><p>  <em>name</em> <code>AS</code> <code>$$</code> <em>sql query</em> <code>$$</code> </p><p>The <em>name</em> and the <em>sql query</em> will be used in a <code>CREATE VIEW</code> statement at the beginning of the data loading, and the resulting view will then be dropped at the end of the data loading. </p><li><em>MATERIALIZE ALL VIEWS</em><p>Same behaviour as <em>MATERIALIZE VIEWS</em> using the dynamic list of views as returned by MySQL rather than asking the user to specify the list. </p></li><li><em>INCLUDING ONLY TABLE NAMES MATCHING</em><p>Introduce a comma separated list of table names or <em>regular expression</em> used to limit the tables to migrate to a sublist. </p></li><p>Example: </p><pre><code>INCLUDING ONLY TABLE NAMES MATCHING ~/film/, 'actor' </code></pre><li><em>EXCLUDING TABLE NAMES MATCHING</em><p>Introduce a comma separated list of table names or <em>regular expression</em> used to exclude table names from the migration. This filter only applies to the result of the <em>INCLUDING</em> filter. </p><pre><code>EXCLUDING TABLE NAMES MATCHING ~&lt;ory&gt; </code></pre></li><li><em>DECODING TABLE NAMES MATCHING</em><p>Introduce a comma separated list of table names or <em>regular expressions</em> used to force the encoding to use when processing data from MySQL. If the data encoding known to you is different from MySQL's idea about it, this is the option to use. </p><pre><code>DECODING TABLE NAMES MATCHING ~/messed/, ~/encoding/ AS utf8 </code></pre></li><p>You can use as many such rules as you need, all with possibly different encodings. </p><li><em>ALTER TABLE NAMES MATCHING</em></li><p>Introduce a comma separated list of table names or <em>regular expressions</em> that you want to target in the pgloader <em>ALTER TABLE</em> command. The only two available actions are <em>SET SCHEMA</em> and <em>RENAME TO</em>, both take a quoted string as parameter: </p><pre><code>ALTER TABLE NAMES MATCHING ~/_list$/, 'sales_by_store', ~/sales_by/  
 SET SCHEMA 'mv'  
 
ALTER TABLE NAMES MATCHING 'film' RENAME TO 'films'  
 
ALTER TABLE NAMES MATCHING ~/./ SET (fillfactor='40') </code></pre><p>You can use as many such rules as you need. The list of tables to be migrated is searched in pgloader memory against the <em>ALTER TABLE</em> matching rules, and for each command pgloader stops at the first matching criteria (regexp or string). </p><p>No <em>ALTER TABLE</em> command is sent to PostgreSQL, the modification happens at the level of the pgloader in-memory representation of your source database schema. In case of a name change, the mapping is kept and reused in the <em>foreign key</em> and <em>index</em> support. </p><p>The <em>SET ()</em> action takes effect as a <em>WITH</em> clause for the <code>CREATE TABLE</code> command that pgloader will run when it has to create a table. </p></ul><h3>LIMITATIONS</h3><p>The <code>database</code> command currently only supports MySQL source database and has the following limitations: </p><ul><li>Views are not migrated,<p>Supporting views might require implementing a full SQL parser for the MySQL dialect with a porting engine to rewrite the SQL against PostgreSQL, including renaming functions and changing some constructs. </p></li><p>While it's not theoretically impossible, don't hold your breath. </p><li>Triggers are not migrated</li><p>The difficulty of doing so is not yet assessed. </p><li><code>ON UPDATE CURRENT_TIMESTAMP</code> is currently not migrated</li><p>It's simple enough to implement, just not on the priority list yet. </p><li>Of the geometric datatypes, only the <code>POINT</code> database has been covered. The other ones should be easy enough to implement now, it's just not done yet. </li></ul><h3>DEFAULT MySQL CASTING RULES</h3><p>When migrating from MySQL the following Casting Rules are provided: </p><p>Numbers: </p><ul><li>type int with extra auto_increment to serial when (&lt; precision 10)</li><li>type int with extra auto_increment to bigserial when (&lt;= 10 precision)</li><li>type int to int       when  (&lt; precision 10)</li><li>type int to bigint    when  (&lt;= 10 precision)</li><li>type tinyint   with extra auto_increment to serial</li><li>type smallint  with extra auto_increment to serial</li><li>type mediumint with extra auto_increment to serial</li><li><p>type bigint    with extra auto_increment to bigserial</p></li><li><p>type tinyint to boolean when (= 1 precision) using tinyint-to-boolean</p></li><li><p>type tinyint to smallint   drop typemod</p></li><li>type smallint to smallint  drop typemod</li><li>type mediumint to integer  drop typemod</li><li>type integer to integer    drop typemod</li><li>type float to float        drop typemod</li><li>type bigint to bigint      drop typemod</li><li><p>type double to double precision drop typemod</p></li><li><p>type numeric to numeric keep typemod</p></li><li>type decimal to decimal keep typemod</li></ul><p>Texts: </p><ul><li>type char       to char keep typemod using remove-null-characters</li><li>type varchar    to varchar keep typemod using remove-null-characters</li><li>type tinytext   to text using remove-null-characters</li><li>type text       to text using remove-null-characters</li><li>type mediumtext to text using remove-null-characters</li><li>type longtext   to text using remove-null-characters</li></ul><p>Binary: </p><ul><li>type binary     to bytea</li><li>type varbinary  to bytea</li><li>type tinyblob   to bytea</li><li>type blob       to bytea</li><li>type mediumblob to bytea</li><li>type longblob   to bytea</li></ul><p>Date: </p><ul><li><p>type datetime when default "0000-00-00 00:00:00" and not null to timestamptz drop not null drop default using zero-dates-to-null </p></li><li><p>type datetime when default "0000-00-00 00:00:00" to timestamptz drop default using zero-dates-to-null </p></li><li><p>type timestamp when default "0000-00-00 00:00:00" and not null to timestamptz drop not null drop default using zero-dates-to-null </p></li><li><p>type timestamp when default "0000-00-00 00:00:00" to timestamptz drop default using zero-dates-to-null </p></li><li><p>type date when default "0000-00-00" to date drop default using zero-dates-to-null </p></li><li><p>type date to date</p></li><li>type datetime to timestamptz</li><li>type timestamp to timestamptz</li><li>type year to integer drop typemod</li></ul><p>Geometric: </p><ul><li>type point to point using pgloader.transforms::convert-mysql-point</li></ul><p>Enum types are declared inline in MySQL and separately with a <code>CREATE TYPE</code> command in PostgreSQL, so each column of Enum Type is converted to a type named after the table and column names defined with the same labels in the same order. </p><p>When the source type definition is not matched in the default casting rules nor in the casting rules provided in the command, then the type name with the typemod is used. </p><h2>LOAD SQLite DATABASE</h2><p>This command instructs pgloader to load data from a SQLite file. Automatic discovery of the schema is supported, including build of the indexes. </p><p>Here's an example: </p><pre><code>load database  
     from sqlite:///Users/dim/Downloads/lastfm_tags.db  
     into postgresql:///tags  
 
 with include drop, create tables, create indexes, reset sequences  
 
  set work_mem to '16MB', maintenance_work_mem to '512 MB'; </code></pre><p>The <code>sqlite</code> command accepts the following clauses and options: </p><ul><li><em>FROM</em><p>Path or HTTP URL to a SQLite file, might be a <code>.zip</code> file. </p></li><li><em>WITH</em><p>When loading from a <code>SQLite</code> database, the following options are supported: </p></li><p>When loading from a <code>SQLite</code> database, the following options are supported, and the default <em>WITH</em> clause is: <em>no truncate</em>, <em>create tables</em>, <em>include drop</em>, <em>create indexes</em>, <em>reset sequences</em>, <em>downcase identifiers</em>, <em>encoding 'utf-8'</em>. </p><ul><li><em>include drop</em><p>When this option is listed, pgloader drops all the tables in the target PostgreSQL database whose names appear in the SQLite database. This option allows for using the same command several times in a row until you figure out all the options, starting automatically from a clean environment. Please note that <code>CASCADE</code> is used to ensure that tables are dropped even if there are foreign keys pointing to them. This is precisely what <code>include drop</code> is intended to do: drop all target tables and recreate them. </p></li><p>Great care needs to be taken when using <code>include drop</code>, as it will cascade to <em>all</em> objects referencing the target tables, possibly including other tables that are not being loaded from the source DB. </p><li><em>include no drop</em></li><p>When this option is listed, pgloader will not include any <code>DROP</code> statement when loading the data. </p><li><em>truncate</em></li><p>When this option is listed, pgloader issue the <code>TRUNCATE</code> command against each PostgreSQL table just before loading data into it. </p><li><em>no truncate</em></li><p>When this option is listed, pgloader issues no <code>TRUNCATE</code> command. </p><li><em>disable triggers</em></li><p>When this option is listed, pgloader issues an <code>ALTER TABLE ... DISABLE TRIGGER ALL</code> command against the PostgreSQL target table before copying the data, then the command <code>ALTER TABLE ... ENABLE TRIGGER ALL</code> once the <code>COPY</code> is done. </p><p>This option allows loading data into a pre-existing table ignoring the <em>foreign key constraints</em> and user defined triggers and may result in invalid <em>foreign key constraints</em> once the data is loaded. Use with care. </p><li><em>create tables</em><p>When this option is listed, pgloader creates the table using the meta data found in the <code>SQLite</code> file, which must contain a list of fields with their data type. A standard data type conversion from DBF to PostgreSQL is done. </p></li><li><em>create no tables</em><p>When this option is listed, pgloader skips the creation of table before loading data, target tables must then already exist. </p></li><p>Also, when using <em>create no tables</em> pgloader fetches the metadata from the current target database and checks type casting, then will remove constraints and indexes prior to loading the data and install them back again once the loading is done. </p><li><em>create indexes</em></li><p> When this option is listed, pgloader gets the definitions of all  the indexes found in the SQLite database and create the same set of  index definitions against the PostgreSQL database. </p><li><em>create no indexes</em></li><p>When this option is listed, pgloader skips the creating indexes. </p><li><em>drop indexes</em></li><p>When this option is listed, pgloader drops the indexes in the target database before loading the data, and creates them again at the end of the data copy. </p><li><em>reset sequences</em></li><p>When this option is listed, at the end of the data loading and after the indexes have all been created, pgloader resets all the PostgreSQL sequences created to the current maximum value of the column they are attached to. </p><li><em>reset no sequences</em></li><p>When this option is listed, pgloader skips resetting sequences after the load. </p><p>The options <em>schema only</em> and <em>data only</em> have no effects on this option. </p><li><em>schema only</em><p>When this option is listed pgloader will refrain from migrating the data over. Note that the schema in this context includes the indexes when the option <em>create indexes</em> has been listed. </p></li><li><em>data only</em><p>When this option is listed pgloader only issues the <code>COPY</code> statements, without doing any other processing. </p></li><li><em>encoding</em><p>This option allows to control which encoding to parse the SQLite text data with. Defaults to UTF-8. </p></li></ul><li><em>CAST</em><p>The cast clause allows to specify custom casting rules, either to overload the default casting rules or to amend them with special cases. </p></li><p>Please refer to the MySQL CAST clause for details. </p><li><em>INCLUDING ONLY TABLE NAMES LIKE</em></li><p>Introduce a comma separated list of table name patterns used to limit the tables to migrate to a sublist. </p><p>Example: </p><pre><code>INCLUDING ONLY TABLE NAMES LIKE 'Invoice%' </code></pre><li><em>EXCLUDING TABLE NAMES LIKE</em><p>Introduce a comma separated list of table name patterns used to exclude table names from the migration. This filter only applies to the result of the <em>INCLUDING</em> filter. </p><pre><code>EXCLUDING TABLE NAMES LIKE 'appointments' </code></pre></li></ul><h3>DEFAULT SQLite CASTING RULES</h3><p>When migrating from SQLite the following Casting Rules are provided: </p><p>Numbers: </p><ul><li>type tinyint to smallint using integer-to-string</li><li><p>type integer to bigint   using integer-to-string</p></li><li><p>type float to float   using float-to-string</p></li><li>type real to real     using float-to-string</li><li>type double to double precision     using float-to-string</li><li>type numeric to numeric     using float-to-string</li></ul><p>Texts: </p><ul><li>type character  to text drop typemod</li><li>type varchar    to text drop typemod</li><li>type nvarchar   to text drop typemod</li><li>type char       to text drop typemod</li><li>type nchar      to text drop typemod</li><li>type nvarchar   to text drop typemod</li><li>type clob       to text drop typemod</li></ul><p>Binary: </p><ul><li>type blob       to bytea</li></ul><p>Date: </p><ul><li>type datetime    to timestamptz using sqlite-timestamp-to-timestamp</li><li>type timestamp   to timestamptz using sqlite-timestamp-to-timestamp</li><li>type timestamptz to timestamptz using sqlite-timestamp-to-timestamp</li></ul><h2>LOAD MS SQL DATABASE</h2><p>This command instructs pgloader to load data from a MS SQL database. Automatic discovery of the schema is supported, including build of the indexes, primary and foreign keys constraints. </p><p>Here's an example: </p><pre><code>load database  
     from mssql://user@host/dbname  
     into postgresql:///dbname  
 
including only table names like 'GlobalAccount' in schema 'dbo'  
 
set work_mem to '16MB', maintenance_work_mem to '512 MB'  
 
before load do $$ drop schema if exists dbo cascade; $$; </code></pre><p>The <code>mssql</code> command accepts the following clauses and options: </p><ul><li><em>FROM</em><p>Connection string to an existing MS SQL database server that listens and welcome external TCP/IP connection. As pgloader currently piggybacks on the FreeTDS driver, to change the port of the server please export the <code>TDSPORT</code> environment variable. </p></li><li><em>WITH</em><p>When loading from a <code>MS SQL</code> database, the same options as when loading a <code>MySQL</code> database are supported. Please refer to the MySQL section. The following options are added: </p><ul><li><em>create schemas</em><p>When this option is listed, pgloader creates the same schemas as found on the MS SQL instance. This is the default. </p></li><li><em>create no schemas</em><p>When this option is listed, pgloader refrains from creating any schemas at all, you must then ensure that the target schema do exist. </p></li></ul></li><li><em>CAST</em><p>The cast clause allows to specify custom casting rules, either to overload the default casting rules or to amend them with special cases. </p></li><p>Please refer to the MySQL CAST clause for details. </p><li><em>INCLUDING ONLY TABLE NAMES LIKE '...' [, '...'] IN SCHEMA '...'</em></li><p>Introduce a comma separated list of table name patterns used to limit the tables to migrate to a sublist. More than one such clause may be used, they will be accumulated together. </p><p>Example: </p><pre><code>including only table names lile 'GlobalAccount' in schema 'dbo' </code></pre><li><em>EXCLUDING TABLE NAMES LIKE '...' [, '...'] IN SCHEMA '...'</em><p>Introduce a comma separated list of table name patterns used to exclude table names from the migration. This filter only applies to the result of the <em>INCLUDING</em> filter. </p><pre><code>EXCLUDING TABLE NAMES MATCHING 'LocalAccount' in schema 'dbo' </code></pre></li><li><em>ALTER SCHEMA '...' RENAME TO '...'</em><p>Allows to rename a schema on the flight, so that for instance the tables found in the schema 'dbo' in your source database will get migrated into the schema 'public' in the target database with this command: </p><pre><code>ALTER SCHEMA 'dbo' RENAME TO 'public' </code></pre></li><li><em>ALTER TABLE NAMES MATCHING ... IN SCHEMA '...'</em><p>See the MySQL explanation for this clause above. It works the same in the context of migrating from MS SQL, only with the added option to specify the name of the schema where to find the definition of the target tables. </p></li><p>The matching is done in pgloader itself, with a Common Lisp regular expression lib, so doesn't depend on the <em>LIKE</em> implementation of MS SQL, nor on the lack of support for regular expressions in the engine. </p></ul><h3>Driver setup and encoding</h3><p>pgloader is using the <code>FreeTDS</code> driver, and internally expects the data to be sent in utf-8. To achieve that, you can configure the FreeTDS driver with those defaults, in the file <code>~/.freetds.conf</code>: </p><pre><code>[global]  
	tds version = 7.4  
	client charset = UTF-8 </code></pre><h3>DEFAULT MS SQL CASTING RULES</h3><p>When migrating from MS SQL the following Casting Rules are provided: </p><p>Numbers: </p><ul><li><p>type tinyint to smallint</p></li><li><p>type float to float   using float-to-string</p></li><li>type real to real     using float-to-string</li><li>type double to double precision     using float-to-string</li><li>type numeric to numeric     using float-to-string</li><li>type decimal to numeric     using float-to-string</li><li>type money to numeric     using float-to-string</li><li>type smallmoney to numeric     using float-to-string</li></ul><p>Texts: </p><ul><li>type char      to text drop typemod</li><li>type nchat     to text drop typemod</li><li>type varchar   to text drop typemod</li><li>type nvarchar  to text drop typemod</li><li>type xml       to text drop typemod</li></ul><p>Binary: </p><ul><li>type binary    to bytea using byte-vector-to-bytea</li><li>type varbinary to bytea using byte-vector-to-bytea</li></ul><p>Date: </p><ul><li>type datetime    to timestamptz</li><li>type datetime2   to timestamptz</li></ul><p>Others: </p><ul><li>type bit to boolean</li><li>type hierarchyid to bytea</li><li>type geography to bytea</li><li>type uniqueidentifier to uuid using sql-server-uniqueidentifier-to-uuid</li></ul><h2>TRANSFORMATION FUNCTIONS</h2><p>Some data types are implemented in a different enough way that a transformation function is necessary. This function must be written in <code>Common lisp</code> and is searched in the <code>pgloader.transforms</code> package. </p><p>Some default transformation function are provided with pgloader, and you can use the <code>--load</code> command line option to load and compile your own lisp file into pgloader at runtime. For your functions to be found, remember to begin your lisp file with the following form: </p><pre><code>(in-package #:pgloader.transforms) </code></pre><p>The provided transformation functions are: </p><ul><li><em>zero-dates-to-null</em><p>When the input date is all zeroes, return <code>nil</code>, which gets loaded as a PostgreSQL <code>NULL</code> value. </p></li><li><em>date-with-no-separator</em><p>Applies <em>zero-dates-to-null</em> then transform the given date into a format that PostgreSQL will actually process: </p><pre><code>In:  "20041002152952"  
Out: "2004-10-02 15:29:52" </code></pre></li><li><em>time-with-no-separator</em><p>Transform the given time into a format that PostgreSQL will actually process: </p><pre><code>In:  "08231560"  
Out: "08:23:15.60" </code></pre></li><li><em>tinyint-to-boolean</em><p>As MySQL lacks a proper boolean type, <em>tinyint</em> is often used to implement that. This function transforms <code>0</code> to <code>'false'</code> and anything else to <code>'true</code>'. </p></li><li><em>bits-to-boolean</em><p>As MySQL lacks a proper boolean type, <em>BIT</em> is often used to implement that. This function transforms 1-bit bit vectors from <code>0</code> to <code>f</code> and any other value to <code>t</code>.. </p></li><li><em>int-to-ip</em><p>Convert an integer into a dotted representation of an ip4. </p><pre><code>In:  18435761  
Out: "1.25.78.177" </code></pre></li><li><em>ip-range</em><p>Converts a couple of integers given as strings into a range of ip4. </p><pre><code>In:  "16825344" "16825599"  
Out: "1.0.188.0-1.0.188.255" </code></pre></li><li><em>convert-mysql-point</em><p>Converts from the <code>astext</code> representation of points in MySQL to the PostgreSQL representation. </p><pre><code>In:  "POINT(48.5513589 7.6926827)"  
Out: "(48.5513589,7.6926827)" </code></pre></li><li><em>integer-to-string</em><p>Converts a integer string or a Common Lisp integer into a string suitable for a PostgreSQL integer. Takes care of quoted integers. </p><pre><code>In:  "\"0\""  
Out: "0" </code></pre></li><li><em>float-to-string</em><p>Converts a Common Lisp float into a string suitable for a PostgreSQL float: </p><pre><code>In:  100.0d0  
Out: "100.0" </code></pre></li><li><em>set-to-enum-array</em><p>Converts a string representing a MySQL SET into a PostgreSQL Array of Enum values from the set. </p><pre><code>In: "foo,bar"  
Out: "{foo,bar}" </code></pre></li><li><em>empty-string-to-null</em><p>Convert an empty string to a null. </p></li><li><em>right-trim</em><p>Remove whitespace at end of string. </p></li><li><em>remove-null-characters</em><p>Remove <code>NUL</code> characters (<code>0x0</code>) from given strings. </p></li><li><em>byte-vector-to-bytea</em><p>Transform a simple array of unsigned bytes to the PostgreSQL bytea Hex Format representation as documented at http://www.postgresql.org/docs/9.3/interactive/datatype-binary.html </p></li><li><em>sqlite-timestamp-to-timestamp</em><p>SQLite type system is quite interesting, so cope with it here to produce timestamp literals as expected by PostgreSQL. That covers year only on 4 digits, 0 dates to null, and proper date strings. </p></li><li><em>sql-server-uniqueidentifier-to-uuid</em><p>The SQL Server driver receives data fo type uniqueidentifier as byte vector that we then need to convert to an UUID string for PostgreSQL COPY input format to process. </p></li><li><em>unix-timestamp-to-timestamptz</em><p>Converts a unix timestamp (number of seconds elapsed since beginning of 1970) into a proper PostgreSQL timestamp format. </p></li><li><em>varbinary-to-string</em><p>Converts binary encoded string (such as a MySQL <code>varbinary</code> entry) to a decoded text, using the table's encoding that may be overloaded with the <em>DECODING TABLE NAMES MATCHING</em> clause. </p></li></ul><h2>LOAD MESSAGES</h2><p>This command is still experimental and allows receiving messages via UDP using a syslog like format, and, depending on rule matching, loads named portions of the data stream into a destination table. </p><pre><code>LOAD MESSAGES  
    FROM syslog://localhost:10514/  
 
 WHEN MATCHES rsyslog-msg IN apache  
  REGISTERING timestamp, ip, rest  
         INTO postgresql://localhost/db?logs.apache  
          SET guc_1 = 'value', guc_2 = 'other value'  
 
 WHEN MATCHES rsyslog-msg IN others  
  REGISTERING timestamp, app-name, data  
         INTO postgresql://localhost/db?logs.others  
          SET guc_1 = 'value', guc_2 = 'other value'  
 
    WITH apache = rsyslog  
         DATA   = IP REST  
         IP     = 1*3DIGIT "." 1*3DIGIT "."1*3DIGIT "."1*3DIGIT  
         REST   = ~/.*/  
 
    WITH others = rsyslog; </code></pre><p>As the command is still experimental the options might be changed in the future and the details are not documented. </p><h2>AUTHOR</h2><p>Dimitri Fontaine <dimitri@2ndQuadrant.fr>  </p><h2>SEE ALSO</h2><p>PostgreSQL COPY documentation at <http://www.postgresql.org/docs/9.3/static/sql-copy.html> . </p><p>The pgloader source code, binary packages, documentation and examples may be downloaded from <http://pgloader.io/> . </p>          </div>
        <div class="col-md-2"> </div>
        </div>

      <!-- FOOTER -->
      <footer>
        <p class="pull-right"><a href="#">Back to top</a></p>
        <p>&copy; 2013-2014 Dimitri Fontaine. &middot;</p>
      </footer>

    </div><!-- /.container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="../dist/js/bootstrap.min.js"></script>
    <!-- <script src="docs-assets/js/holder.js"></script> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47059482-2', 'tapoueh.org');
  ga('send', 'pageview');

</script>
  </body>
</html>
